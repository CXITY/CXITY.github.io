<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>godot入门</title>
      <link href="/2025/08/11/godot%E5%85%A5%E9%97%A8/"/>
      <url>/2025/08/11/godot%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><hr><p>我认为代码的学习是根据工作的内容而不断学习的,所以这个基础无疑是无真正作用的.只需要记住入门篇比较重视格式,会照葫芦画瓢即可.</p><hr><h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var number : int = 10</span><br><span class="line">var str := &quot;hello&quot;</span><br></pre></td></tr></table></figure><h3 id="2-控制语句"><a href="#2-控制语句" class="headerlink" title="2. 控制语句"></a>2. 控制语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var flag := true</span><br><span class="line">if flag:</span><br><span class="line">    print(&quot;flag is true&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;flag is false&quot;)</span><br></pre></td></tr></table></figure><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h3><ol><li>普通函数belike:func表示函数,括号内为参数(注意尽量定义参数的类型),-&gt;后决定函数的返回值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func test() -&gt; void:</span><br><span class="line">    print(&quot;this is a function&quot;)</span><br></pre></td></tr></table></figure><ol start="2"><li>匿名函数(lambda表达式):没有名字的函数,其对应的类型为Callable</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var lambda_func : Callable = func() -&gt; void:</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">lambda_func.call() # call()可调用该匿名函数</span><br></pre></td></tr></table></figure><p>匿名函数使用:在实际开发中,信号的绑定可以使用传入匿名函数(先看节点之间通信的知识)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">signal my_signal(name : String)</span><br><span class="line"></span><br><span class="line">var lambda_func : Callable = func(str : String) -&gt; void:</span><br><span class="line">    print(str)</span><br><span class="line"></span><br><span class="line">func connection() -&gt; void:</span><br><span class="line">    my_signal.connect(lambda_func)</span><br><span class="line">    my_signal.emit(&quot;这是一条信号&quot;)</span><br></pre></td></tr></table></figure><h3 id="4-类"><a href="#4-类" class="headerlink" title="4. 类"></a>4. 类</h3><p>1.class关键字,该类型只能在节点内部使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class TestClass:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>2.class_name关键字,可以将节点申明为全局的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_name Test</span><br></pre></td></tr></table></figure><h3 id="5-常见注解"><a href="#5-常见注解" class="headerlink" title="5. 常见注解"></a>5. 常见注解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 1.@export</span><br><span class="line"># 可以在检查器面板中编辑,即在节点信息栏中的检查器显示出该变量,这个变量可在外部附上合适的内容</span><br><span class="line">@export var number := 1</span><br><span class="line"></span><br><span class="line"># 2.@onready</span><br><span class="line"># 在_ready()之前不会被赋值,_ready触发才赋值</span><br><span class="line">@onready var str := &quot;hello&quot;</span><br><span class="line"></span><br><span class="line"># 3.@tool</span><br><span class="line"># 将当前脚本申明为工具脚本,允许该脚本由编辑器所加载与执行</span><br></pre></td></tr></table></figure><ol start="6"><li>数组与集合</li></ol><p>数组:一组相同元素,有先后顺序的结构.一般用于顺序存储,随机访问</p><p>集合:字典dictionary的key-value键值对提供了便利的查询结构</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><h3 id="节点node理解"><a href="#节点node理解" class="headerlink" title="节点node理解"></a>节点node理解</h3><ol><li>节点:通俗解释其实就是godot提供的用于构成场景的基本元素,每一个节点都有自己特有的属性,都继承自Node这个祖节点</li><li>每一个node节点都可以关联一个脚本,可视为是对节点的扩展</li><li>节点之间关联变成树,这个树就是场景树,场景就是节点和脚本的集合.当然这些概念是相对的,这个场景可以是另外一个大的场景的节点</li></ol><h3 id="节点之间通信"><a href="#节点之间通信" class="headerlink" title="节点之间通信"></a>节点之间通信</h3><ol><li>直接调用,将其他节点拖拽到当前节点的脚本中,相当于引用节点,直接调用节点的变量或函数即可</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 1.直接调用</span><br><span class="line"># UI.gd</span><br><span class="line">extends Control</span><br><span class="line"></span><br><span class="line">func update_health(damage: int):</span><br><span class="line">    print(&quot;血量更新:&quot;, damage)</span><br><span class="line"></span><br><span class="line"># Player.gd</span><br><span class="line">extends CharacterBody3D</span><br><span class="line"></span><br><span class="line">@export var ui_node: NodePath  # 在编辑器中拖入UI节点</span><br><span class="line">var ui: Control</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">    ui = get_node(ui_node)  # 获取UI节点</span><br><span class="line"></span><br><span class="line">func take_damage(damage: int):</span><br><span class="line">    ui.update_health(damage)  # 直接调用UI的方法</span><br></pre></td></tr></table></figure><ol start="2"><li>信号:一个脚本里定义信号,触发某个函数条件则emit发送信号;另一个脚本connect之前脚本提供的信号与自己提供的函数.一旦触发信号就会使得脚本接收并执行相应连接的函数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Enemy.gd</span><br><span class="line">extends CharacterBody3D</span><br><span class="line"></span><br><span class="line">signal enemy_died(score_value: int)  # 定义信号</span><br><span class="line"></span><br><span class="line">func die():</span><br><span class="line">    emit_signal(&quot;enemy_died&quot;, 10)  # 死亡时发出信号</span><br><span class="line"></span><br><span class="line"># GameManager.gd</span><br><span class="line">extends Node</span><br><span class="line"></span><br><span class="line">func _ready():</span><br><span class="line">    var enemy = get_node(&quot;Enemy&quot;)</span><br><span class="line">    enemy.enemy_died.connect(_on_enemy_died)  # 连接信号</span><br><span class="line"></span><br><span class="line">func _on_enemy_died(score_value: int):</span><br><span class="line">    print(&quot;获得分数:&quot;, score_value)</span><br></pre></td></tr></table></figure><ol start="3"><li>组group:get_tree().call_group(group, func)这样可以直接获取当前场景树下某一个节点(group)的方法(func)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Switch.gd</span><br><span class="line">func _on_pressed():  </span><br><span class="line">    get_tree().call_group(&quot;lights&quot;, &quot;toggle&quot;)</span><br><span class="line"></span><br><span class="line"># Light.gd  </span><br><span class="line">func toggle():  </span><br><span class="line">    print(&quot;be done&quot;)</span><br></pre></td></tr></table></figure><h1 id="面向对象OOP"><a href="#面向对象OOP" class="headerlink" title="面向对象OOP"></a>面向对象OOP</h1><p>三大特性:封装,继承,多态</p><p>封装:节点是场景最基本的单位,这个节点能提供给场景各种功能.封装的作用就是如何通过这个节点去调用函数或者属性.就好比你想发送一条确认信息,有一个功能性的节点提供了这个方法,那么你直接使用这个节点的方法即可,而不是每一次都去copy一份函数到自己的节点里.</p><p>继承:class_name使得一个节点能够被视为是一个类.extends起到继承节点的作用.继承的节点拥有父节点的属性与方法.并且能自己重写这些属性和方法,此外能通过super()去调用父节点的方法.</p><p>多态:父节点能被很多子节点继承,这些继承的节点对于父节点的函数方法重写了,使得在表现上两个节点虽然调用了同一个方法,但是最终的效果不一样.比如同样是角色,敌人的交互可能是攻击,而朋友的交互可能是对话.</p><h1 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h1><p>Node有一些自带的函数需要解释:</p><ol><li>_init():用于构建初始化一个节点,相当于场景栏里面创造一个节点</li><li>_enter_tree():一个节点如果想要被执行,那么一定要在场景树下,这也是为什么父节点需要add_child()添加子节点.相当于场景栏给父节点挂上子节点</li><li>_ready():挂上节点树后执行的函数,表示当前这个节点已经准备好了.注意对于节点树而言,所有子节点准备好了父节点才准备</li><li>_phycsics_process():物理帧,真正的一帧里需要执行</li><li>_process():一帧,不过区别于_phycsics_process(),并非物理帧,它将执行完里面的内容视作一帧</li><li>_input():接受到玩家的输入</li><li>_unhandled_input():处理没有处理的玩家输入</li><li>_exit_tree():退出节点树之前执行</li><li>queen_free():将节点存放到准备释放队列中,当前帧结束才释放节点</li><li>free():从内存中直接删除节点</li></ol><p>场景树:</p><ol><li>get_tree():获取SceneTree场景树管理器,get_tree().root获取最顶层节点</li><li>exit():退出场景树</li></ol><p>关于组:</p><ol><li>节点之间想要通信可以使用组.add_to_group()将节点添加到某个组中</li><li>call_group()调用组内所有节点的同名函数</li></ol><h1 id="Resource资源"><a href="#Resource资源" class="headerlink" title="Resource资源"></a>Resource资源</h1><p>资源其实就是存在外部磁盘的节点,脚本和场景.只是这个节点经过了序列化存入磁盘里变成了项目内外随意获取的资源.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
